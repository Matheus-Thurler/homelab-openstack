// pipeline {
//   agent any

//   environment {
//     // Definindo credenciais globais para a pipeline
//     AWS_ACCESS_KEY_ID     = credentials('aws-access-key-id')
//     AWS_SECRET_ACCESS_KEY = credentials('aws-secret-access-key')
//     JENKINS_PUB_KEY       = credentials('jenkins-pub-key')
//   }

//   parameters {
//     choice(
//       name: 'CREATE_OR_DESTROY',
//       choices: ['Create', 'Destroy'],
//       description: 'Deseja criar ou destruir a infraestrutura?'
//     )
//   }

//   stages {

//     // Etapa 1: Limpa o workspace para garantir uma execução limpa
//     stage('Preparation') {
//       steps {
//         echo 'Limpando o workspace...'
//         deleteDir()
//       }
//     }

//     // Etapa 2: Prepara as chaves SSH no workspace
//     stage('authentication') {
//       agent {
//         docker { image 'alpine' }
//       }
//       steps {
//         // Usa o withCredentials para carregar a chave privada de forma segura
//         withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-priv-key', keyFileVariable: 'JENKINS_PRIV_KEY')]) {
//           sh '''
//             # Copia a chave privada e pública para arquivos no workspace
//             cp "$JENKINS_PRIV_KEY" id_rsa
//             echo "$JENKINS_PUB_KEY" > id_rsa.pub
//             # Garante a permissão correta para a chave privada
//             chmod 600 id_rsa
//             echo "Chaves SSH preparadas no workspace."
//           '''
//         }
//       }
//     }

//     // NOVO STAGE: Etapa 3 - Baixa a configuração do OpenStack (clouds.yaml)
//     stage('Download OpenStack Config') {
//       agent {
//         docker {
//           image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'
//           args '-u root --entrypoint=""'
//         }
//       }
//       environment {
//         MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
//         MINIO_ACCESS_KEY = credentials('aws-access-key-id')
//         MINIO_SECRET_KEY = credentials('aws-secret-access-key')
//       }
//       steps {
//         sh '''
//           set -e
//           echo "Configurando alias para o MinIO..."
//           mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4

//           echo "Baixando o arquivo clouds.yaml do MinIO..."
//           # Assume que o arquivo está em 'arquivos-openstack/clouds.yaml'
//           mc cp deploy/arquivos-openstack/clouds.yaml ./clouds.yaml
          
//           echo "Download do clouds.yaml concluído."
//           ls -l clouds.yaml
//         '''
//       }
//     }

//     // Etapa 4: Inicializa o Terraform
//     stage('init') {
//       agent {
//         docker {
//           image 'hashicorp/terraform:1.9.8'
//           // Roda como root para evitar problemas de permissão
//           args '-u root --entrypoint=""'
//         }
//       }
//       steps {
//         sh 'terraform init -reconfigure -no-color'
//       }
//     }

//     // Etapa 5: Gera o plano do Terraform
//     stage('plan') {
//       when { expression { params.CREATE_OR_DESTROY == "Create" } }
//       agent {
//         docker {
//           image 'hashicorp/terraform:1.9.8'
//           args '-u root --entrypoint=""'
//         }
//       }
//       steps {
//         sh 'terraform plan -no-color'
//       }
//     }

//     // Etapa 6: Aplica as configurações do Terraform
//     stage('apply') {
//       when { expression { params.CREATE_OR_DESTROY == "Create" } }
//       agent {
//         docker {
//           image 'hashicorp/terraform:1.9.8'
//           args '-u root --entrypoint=""'
//         }
//       }
//       steps {
//         sh '''
//           # Garante que o script pare se houver um erro
//           set -e
          
//           echo "Executando terraform apply..."
//           terraform apply -no-color -auto-approve

//           echo "Salvando o IP da VPN em um arquivo..."
//           # O '-raw' remove as aspas do output, salvando apenas o IP puro
//           terraform output -raw openvpn_ip > openvpn_ip.txt

//           echo "IP salvo:"
//           cat openvpn_ip.txt
//         '''
//       }
//     }
    
//     // Etapa 7: Baixa o arquivo de configuração da VPN
//     stage('Download OpenVPN Config') {
//       when { expression { params.CREATE_OR_DESTROY == "Create" } }
//       agent {
//         docker {
//           image 'alpine:latest'
//           args '-u root --entrypoint=""'
//         }
//       }
//       steps {
//         sh '''
//           set -e 

//           # Instala o cliente OpenSSH (ssh e scp)
//           apk update && apk add --no-cache openssh-client

//           IP_ADDRESS=$(cat openvpn_ip.txt)
//           if [ -z "$IP_ADDRESS" ]; then
//             echo "ERRO: Não foi possível ler o endereço IP."
//             exit 1
//           fi

//           echo "Tentando conectar na instância com IP: $IP_ADDRESS"

//           # Loop para aguardar o arquivo client.ovpn ser gerado
//           echo "Aguardando o arquivo client.ovpn ser gerado na instância..."
//           # Tenta por 5 minutos
//           for i in $(seq 1 30); do
//             if ssh -i id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@$IP_ADDRESS "test -f /home/ubuntu/client.ovpn"; then
//               echo "Arquivo encontrado na instância!"
//               break
//             fi
//             echo "Arquivo ainda não está pronto. Tentando novamente em 10s..."
//             sleep 10
//             if [ $i -eq 30 ]; then
//                 echo "ERRO: Timeout esperando pelo arquivo client.ovpn."
//                 exit 1
//             fi
//           done

//           echo "Baixando o arquivo client.ovpn..."
//           scp -i id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
//             ubuntu@$IP_ADDRESS:/home/ubuntu/client.ovpn ./client.ovpn
          
//           echo "Download concluído com sucesso!"
//           ls -l client.ovpn
//         '''
//       }
//     }

//     // Etapa 8: Faz o upload do arquivo para o MinIO
//     stage('Fazer Upload para o MinIO') {
//       when { expression { params.CREATE_OR_DESTROY == "Create" } }
//       agent {
//         docker {
//           image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'
//           args '-u root --entrypoint=""'
//         }
//       }
//       environment {
//         MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
//         MINIO_ACCESS_KEY = credentials('aws-access-key-id')
//         MINIO_SECRET_KEY = credentials('aws-secret-access-key')
//       }
//       steps {
//         sh  '''
//           # O 'if' precisa de um espaço depois do '[' e antes do ']'
//           if [ -f "client.ovpn" ]; then
//             mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4
//             mc cp client.ovpn deploy/arquivos-openstack/
//             echo "Arquivo client.ovpn enviado para o MinIO."
//           else
//             echo "Arquivo client.ovpn não encontrado para upload."
//             exit 1
//           fi
//         '''
//       }
//     }

//     stage('kubespray') {
//       agent {
//         docker {
//           image 'quay.io/kubespray/kubespray:v2.26.0'
//           args '--entrypoint="" -u root'
//         }
//       }
//       steps {
//         dir('./') {
//           sh '''
//             export ANSIBLE_ROLES_PATH="$ANSIBLE_ROLES_PATH:/kubespray/roles"
//             export ANSIBLE_HOST_KEY_CHECKING="False"

//             ansible-playbook \
//               --become \
//               --inventory inventory.ini \
//               --extra-vars "kube_network_plugin=flannel" \
//               --private-key id_rsa \
//               /kubespray/cluster.yml
//           '''
//         }
//       }
//       when {
//         expression {
//           params.CREATE_OR_DESTROY == "Create"
//         }
//       }
//     }

//     // Etapa de Destruição da Infraestrutura
//     stage('Destroy Infrastructure') {
//       when { expression { params.CREATE_OR_DESTROY == "Destroy" } }
//       agent {
//         docker {
//           image 'hashicorp/terraform:1.9.8'
//           args '-u root --entrypoint=""'
//         }
//       }
//       steps {
//         sh 'terraform apply -destroy -no-color -auto-approve'
//       }
//     }

//     // Etapa de Limpeza do Artefato no MinIO
//     stage('Cleanup MinIO') {
//       when { expression { params.CREATE_OR_DESTROY == "Destroy" } }
//       agent {
//         docker {
//           image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'
//           args '-u root --entrypoint=""'
//         }
//       }
//       environment {
//         MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
//         MINIO_ACCESS_KEY = credentials('aws-access-key-id')
//         MINIO_SECRET_KEY = credentials('aws-secret-access-key')
//       }
//       steps {
//         sh '''
//           echo "Configurando alias para o MinIO..."
//           mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4

//           echo "Verificando se o arquivo client.ovpn existe no MinIO antes de remover..."
//           # 'mc stat' retorna um erro se o arquivo não existir.
//           if mc stat deploy/arquivos-openstack/client.ovpn > /dev/null 2>&1; then
//             echo "Arquivo encontrado. Removendo client.ovpn do MinIO..."
//             mc rm deploy/arquivos-openstack/client.ovpn
//             echo "Arquivo removido com sucesso."
//           else
//             echo "Arquivo client.ovpn não foi encontrado no MinIO. Nenhuma ação necessária."
//           fi
//         '''
//       }
//     }
//   }
// }
pipeline {
  agent any

  environment {
    AWS_ACCESS_KEY_ID      = credentials('aws-access-key-id')
    AWS_SECRET_ACCESS_KEY  = credentials('aws-secret-access-key')
    JENKINS_PUB_KEY        = credentials('jenkins-pub-key')
    GH_PAT                 = credentials('github-pat')
    GITHUB_OWNER           = 'Matheus-Thurler'
    GITHUB_REPO            = 'homelab-openstack'
    IMAGE_BASENAME         = 'kubespray-openvpn'
  }

  parameters {
    choice(
      name: 'CREATE_OR_DESTROY',
      choices: ['Create', 'Destroy'],
      description: 'Deseja criar ou destruir a infraestrutura?'
    )
  }

  stages {
    stage('Preparation') {
      steps { deleteDir() }
    }

    stage('authentication') {
      agent { docker { image 'alpine' } }
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-priv-key', keyFileVariable: 'JENKINS_PRIV_KEY')]) {
          sh '''
            cp "$JENKINS_PRIV_KEY" id_rsa
            echo "$JENKINS_PUB_KEY" > id_rsa.pub
            chmod 600 id_rsa
          '''
        }
      }
    }

    stage('Define Image Name') {
      agent any
      steps {
        script {
          def imageTag = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          def githubOwnerLower = env.GITHUB_OWNER.toLowerCase()
          env.IMAGE_FULL_NAME = "ghcr.io/${githubOwnerLower}/${env.GITHUB_REPO}/${env.IMAGE_BASENAME}:${imageTag}"
          echo "Imagem: ${env.IMAGE_FULL_NAME}"
        }
      }
    }

    stage('Download OpenStack Config') {
      agent {
        docker { image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'; args '-u root --entrypoint=""' }
      }
      environment {
        MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
        MINIO_ACCESS_KEY = credentials('aws-access-key-id')
        MINIO_SECRET_KEY = credentials('aws-secret-access-key')
      }
      steps {
        sh '''
          mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4
          mc cp deploy/arquivos-openstack/clouds.yaml ./clouds.yaml
        '''
      }
    }

    // --- BLOCO PARA 'CREATE' ---
    stage('Create Workflow') {
      when { expression { params.CREATE_OR_DESTROY == "Create" } }
      stages {
        stage('Build & Push Kubespray Image') {
          agent any 
          steps {
            script {
              def githubOwnerLower = env.GITHUB_OWNER.toLowerCase()
              echo "Construindo imagem: ${env.IMAGE_FULL_NAME}"
              sh """
                echo "${GH_PAT}" | docker login ghcr.io -u "${githubOwnerLower}" --password-stdin
                docker build -t "${IMAGE_FULL_NAME}" .
                docker push "${IMAGE_FULL_NAME}"
              """
            }
          }
        }
        
        stage('Terraform Init & Apply') {
          agent {
            docker { image 'hashicorp/terraform:1.9.8'; args '-u root --entrypoint=""' }
          }
          steps {
            sh '''
              terraform init -reconfigure -no-color
              terraform plan -no-color
              terraform apply -no-color -auto-approve
              terraform output -raw openvpn_ip > openvpn_ip.txt
              echo "IP salvo:" && cat openvpn_ip.txt
            '''
          }
        }
        
        stage('Download & Upload VPN Config') {
          stages {
            stage('Download from Instance') {
              agent { docker { image 'alpine:latest'; args '-u root --entrypoint=""' } }
              steps {
                sh '''
                  set -e 
                  apk update && apk add --no-cache openssh-client
                  IP_ADDRESS=$(cat openvpn_ip.txt)
                  if [ -z "$IP_ADDRESS" ]; then echo "ERRO: IP não encontrado."; exit 1; fi
                  echo "Aguardando client.ovpn na instância $IP_ADDRESS..."
                  for i in $(seq 1 30); do
                      if ssh -i id_rsa -o StrictHostKeyChecking=no ubuntu@$IP_ADDRESS "test -f /home/ubuntu/client.ovpn"; then
                          echo "Arquivo encontrado!" && break
                      fi
                      echo "Aguardando 10s..." && sleep 10
                      if [ $i -eq 30 ]; then echo "ERRO: Timeout." && exit 1; fi
                  done
                  scp -i id_rsa -o StrictHostKeyChecking=no ubuntu@$IP_ADDRESS:/home/ubuntu/client.ovpn ./client.ovpn
                  echo "Download concluído!"
                '''
              }
            }
            stage('Upload to MinIO') {
              agent { docker { image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'; args '-u root --entrypoint=""' } }
              environment {
                  MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
                  MINIO_ACCESS_KEY = credentials('aws-access-key-id')
                  MINIO_SECRET_KEY = credentials('aws-secret-access-key')
              }
              steps {
                sh '''
                  if [ -f "client.ovpn" ]; then
                      mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4
                      mc cp client.ovpn deploy/arquivos-openstack/
                      echo "client.ovpn enviado para o MinIO."
                  else
                      echo "client.ovpn não encontrado." && exit 1
                  fi
                '''
              }
            }
          }
        }
        
        stage('Deploy Kubespray (via VPN)') {
          agent {
            docker {
              image "${env.IMAGE_FULL_NAME}"
              args '--cap-add NET_ADMIN --device /dev/net/tun --entrypoint="" -u root'
            }
          }
          steps {
            sh '''
              set -e
              echo "Iniciando VPN..."
              openvpn --config client.ovpn > openvpn.log 2>&1 &
              for i in $(seq 1 10); do 
                if ip a | grep -q tun0; then
                  echo "VPN conectada." && break
                fi
                sleep 10
                if [ $i -eq 10 ]; then
                    echo "ERRO: Timeout VPN." && cat openvpn.log && exit 1
                fi
              done
              
              export ANSIBLE_HOST_KEY_CHECKING="False"
              export ANSIBLE_ROLES_PATH="/kubespray/roles"
              
              cp inventory.ini /kubespray/inventory.ini
              cp id_rsa /kubespray/
              chmod 600 /kubespray/id_rsa
              
              cd /kubespray
              ansible-playbook \
                --become \
                --inventory inventory.ini \
                --extra-vars "kube_network_plugin=flannel" \
                --private-key id_rsa \
                cluster.yml
                
              pkill openvpn
            '''
          }
        }
        
        // NOVA ETAPA - SÓ EXECUTA NO CREATE
        stage('Deploy Kubeconfig to MinIO') {
          when { expression { params.CREATE_OR_DESTROY == "Create" } }
          agent {
            docker { 
              image 'alpine:latest'
              args '-u root --entrypoint=""'
            }
          }
          environment {
            MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
            MINIO_ACCESS_KEY = credentials('aws-access-key-id')
            MINIO_SECRET_KEY = credentials('aws-secret-access-key')
          }
          steps {
            sh '''
              set -e
              echo "=== Configurando cliente MinIO ==="
              apk update && apk add --no-cache minio-client openssh-client
              mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4
              
              echo "=== Conectando via VPN ==="
              openvpn --config client.ovpn > /tmp/openvpn.log 2>&1 &
              sleep 15
              
              IP_ADDRESS=$(cat openvpn_ip.txt)
              echo "IP da instância: $IP_ADDRESS"
              
              echo "=== Buscando kubeconfig ==="
              ssh -i id_rsa -o StrictHostKeyChecking=no ubuntu@$IP_ADDRESS "
                if [ -f '/etc/kubernetes/admin.conf' ]; then
                  sudo cat /etc/kubernetes/admin.conf
                else
                  sudo find / -name 'admin.conf' -type f 2>/dev/null | head -1 | xargs sudo cat
                fi
              " > cluster-config.yaml
              
              if [ -s "cluster-config.yaml" ]; then
                echo "=== Kubeconfig recuperado ==="
                mc cp cluster-config.yaml deploy/arquivos-openstack/kubeconfig.yaml
                echo "✅ Kubeconfig enviado para o MinIO!"
                
                TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                mc cp cluster-config.yaml deploy/arquivos-openstack/backups/kubeconfig_${TIMESTAMP}.yaml
                echo "Backup: kubeconfig_${TIMESTAMP}.yaml"
              else
                echo "❌ Erro ao recuperar kubeconfig"
                exit 1
              fi
              
              pkill openvpn
            '''
          }
        }
      }
    }

    // --- BLOCO PARA 'DESTROY' ---
    stage('Destroy Workflow') {
      when { expression { params.CREATE_OR_DESTROY == "Destroy" } }
      stages {
        stage('Destroy Infrastructure') {
          agent {
            docker { image 'hashicorp/terraform:1.9.8'; args '-u root --entrypoint=""' }
          }
          steps {
            sh '''
              terraform init -reconfigure -no-color
              terraform apply -destroy -no-color -auto-approve
            '''
          }
        }
        stage('Cleanup MinIO') {
          agent {
            docker { image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'; args '-u root --entrypoint=""' }
          }
          environment {
            MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
            MINIO_ACCESS_KEY = credentials('aws-access-key-id')
            MINIO_SECRET_KEY = credentials('aws-secret-access-key')
          }
          steps {
            sh '''
              mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4
              if mc stat deploy/arquivos-openstack/client.ovpn > /dev/null 2>&1; then
                echo "Removendo client.ovpn..."
                mc rm deploy/arquivos-openstack/client.ovpn
              fi
              if mc stat deploy/arquivos-openstack/kubeconfig.yaml > /dev/null 2>&1; then
                echo "Removendo kubeconfig..."
                mc rm deploy/arquivos-openstack/kubeconfig.yaml
              fi
              echo "Limpeza concluída."
            '''
          }
        }
      }
    }
  }
}
pipeline {
  agent any

  environment {
    // Definindo credenciais globais para a pipeline
    AWS_ACCESS_KEY_ID     = credentials('aws-access-key-id')
    AWS_SECRET_ACCESS_KEY = credentials('aws-secret-access-key')
    JENKINS_PUB_KEY       = credentials('jenkins-pub-key')
  }

  parameters {
    choice(
      name: 'CREATE_OR_DESTROY',
      choices: ['Create', 'Destroy'],
      description: 'Deseja criar ou destruir a infraestrutura?'
    )
  }

  stages {

    // Etapa 1: Prepara as chaves SSH no workspace
    stage('authentication') {
      agent {
        docker { image 'alpine' }
      }
      steps {
        // Usa o withCredentials para carregar a chave privada de forma segura
        withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-priv-key', keyFileVariable: 'JENKINS_PRIV_KEY')]) {
          sh '''
            # Copia a chave privada e pública para arquivos no workspace
            cp "$JENKINS_PRIV_KEY" id_rsa
            echo "$JENKINS_PUB_KEY" > id_rsa.pub
            # Garante a permissão correta para a chave privada
            chmod 600 id_rsa
            echo "Chaves SSH preparadas no workspace."
          '''
        }
      }
    }

    // Etapa 2: Limpa o workspace para garantir uma execução limpa
    stage('Preparation') {
      steps {
        echo 'Limpando o workspace...'
        deleteDir()
      }
    }

    // Etapa 3: Inicializa o Terraform
    stage('init') {
      agent {
        docker {
          image 'hashicorp/terraform:1.9.8'
          // Roda como root para evitar problemas de permissão
          args '-u root --entrypoint=""'
        }
      }
      steps {
        sh 'terraform init -reconfigure -no-color'
      }
    }

    // Etapa 4: Gera o plano do Terraform
    stage('plan') {
      when { expression { params.CREATE_OR_DESTROY == "Create" } }
      agent {
        docker {
          image 'hashicorp/terraform:1.9.8'
          args '-u root --entrypoint=""'
        }
      }
      steps {
        sh 'terraform plan -no-color'
      }
    }

    // Etapa 5: Aplica as configurações do Terraform
    stage('apply') {
      when { expression { params.CREATE_OR_DESTROY == "Create" } }
      agent {
        docker {
          image 'hashicorp/terraform:1.9.8'
          args '-u root --entrypoint=""'
        }
      }
      steps {
        sh '''
          # Garante que o script pare se houver um erro
          set -e
          
          echo "Executando terraform apply..."
          terraform apply -no-color -auto-approve

          echo "Salvando o IP da VPN em um arquivo..."
          # O '-raw' remove as aspas do output, salvando apenas o IP puro
          terraform output -raw openvpn_ip > openvpn_ip.txt

          echo "IP salvo:"
          cat openvpn_ip.txt
        '''
      }
    }
    
    // Etapa 6: Baixa o arquivo de configuração da VPN
    stage('Download OpenVPN Config') {
      when { expression { params.CREATE_OR_DESTROY == "Create" } }
      agent {
        docker {
          image 'alpine:latest'
          args '-u root --entrypoint=""'
        }
      }
      steps {
        sh '''
          set -e 

          # Instala o cliente OpenSSH (ssh e scp)
          apk update && apk add --no-cache openssh-client

          IP_ADDRESS=$(cat openvpn_ip.txt)
          if [ -z "$IP_ADDRESS" ]; then
            echo "ERRO: Não foi possível ler o endereço IP."
            exit 1
          fi

          echo "Tentando conectar na instância com IP: $IP_ADDRESS"

          # Loop para aguardar o arquivo client.ovpn ser gerado
          echo "Aguardando o arquivo client.ovpn ser gerado na instância..."
          # Tenta por 5 minutos
          for i in $(seq 1 30); do
            if ssh -i id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@$IP_ADDRESS "test -f /home/ubuntu/client.ovpn"; then
              echo "Arquivo encontrado na instância!"
              break
            fi
            echo "Arquivo ainda não está pronto. Tentando novamente em 10s..."
            sleep 10
            if [ $i -eq 30 ]; then
                echo "ERRO: Timeout esperando pelo arquivo client.ovpn."
                exit 1
            fi
          done

          echo "Baixando o arquivo client.ovpn..."
          scp -i id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ubuntu@$IP_ADDRESS:/home/ubuntu/client.ovpn ./client.ovpn
          
          echo "Download concluído com sucesso!"
          ls -l client.ovpn
        '''
      }
    }

    // Etapa 7: Faz o upload do arquivo para o MinIO
    stage('Fazer Upload para o MinIO') {
      when { expression { params.CREATE_OR_DESTROY == "Create" } }
      agent {
        docker {
          image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'
          args '-u root --entrypoint=""'
        }
      }
      environment {
        MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
        MINIO_ACCESS_KEY = credentials('aws-access-key-id')
        MINIO_SECRET_KEY = credentials('aws-secret-access-key')
      }
      steps {
        sh  '''
          # O 'if' precisa de um espaço depois do '[' e antes do ']'
          if [ -f "client.ovpn" ]; then
            mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4
            mc cp client.ovpn deploy/arquivos-openstack/
            echo "Arquivo client.ovpn enviado para o MinIO."
          else
            echo "Arquivo client.ovpn não encontrado para upload."
            exit 1
          fi
        '''
      }
    }

    // Etapa de Destruição da Infraestrutura
    stage('Destroy Infrastructure') {
      when { expression { params.CREATE_OR_DESTROY == "Destroy" } }
      agent {
        docker {
          image 'hashicorp/terraform:1.9.8'
          args '-u root --entrypoint=""'
        }
      }
      steps {
        sh 'terraform apply -destroy -no-color -auto-approve'
      }
    }

    // NOVO STAGE: Etapa de Limpeza do Artefato no MinIO
    stage('Cleanup MinIO') {
      when { expression { params.CREATE_OR_DESTROY == "Destroy" } }
      agent {
        docker {
          image 'minio/mc:RELEASE.2025-08-13T08-35-41Z'
          args '-u root --entrypoint=""'
        }
      }
      environment {
        MINIO_ENDPOINT   = 'http://192.168.68.110:9000'
        MINIO_ACCESS_KEY = credentials('aws-access-key-id')
        MINIO_SECRET_KEY = credentials('aws-secret-access-key')
      }
      steps {
        sh '''
          echo "Configurando alias para o MinIO..."
          mc alias set deploy $MINIO_ENDPOINT $MINIO_ACCESS_KEY $MINIO_SECRET_KEY --api S3v4

          echo "Verificando se o arquivo client.ovpn existe no MinIO antes de remover..."
          # 'mc stat' retorna um erro se o arquivo não existir. O '|| true' evita que a pipeline falhe.
          if mc stat deploy/arquivos-openstack/client.ovpn > /dev/null 2>&1; then
            echo "Arquivo encontrado. Removendo client.ovpn do MinIO..."
            mc rm deploy/arquivos-openstack/client.ovpn
            echo "Arquivo removido com sucesso."
          else
            echo "Arquivo client.ovpn não foi encontrado no MinIO. Nenhuma ação necessária."
          fi
        '''
      }
    }
  }
}